package entities

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"strings"
	"text/template"

	"gopkg.in/yaml.v1"
)

var (
	defaultVarType = "string"

	workspaceTemplate = `// DO NOT EDIT (this file is automatically generated)
resource "tfe_workspace" "{{ .Metadata.ID }}" {
	organization 					= "{{ .Metadata.Organization }}"
	name         					= "{{ .Metadata.Name }}"
	working_directory 		= "{{ .Spec.WorkingDirectory }}"
	auto_apply 						= {{ .Spec.AutoApply }}
	file_triggers_enabled = {{ .Spec.FileTriggersEnabled }}
	queue_all_runs 				= {{ .Spec.QueueAllRuns }}
	vcs_repo {
		identifier         = "{{ .Spec.VCSRepo.Identifier }}"
		branch             = "{{ .Spec.VCSRepo.Branch }}"
		ingress_submodules = {{ .Spec.VCSRepo.IngressSubmodules }}
		oauth_token_id     = "{{ .Spec.VCSRepo.OauthTokenID }}"
	}
}

// variable declarations:
{{ with .Spec.Resources.Vars }}
{{ range . }}variable "{{ $.Metadata.ID }}_var_{{ .Name }}" {}

resource "tfe_variable" "{{ $.Metadata.ID }}_var_{{ .Name }}" {
	workspace_id = tfe_workspace.{{ $.Metadata.ID }}.id
	key          = "{{ .Name }}"
	value        = var.{{ $.Metadata.ID }}_var_{{ .Name }}
	category     = "terraform"{{ if .Sensitive }}
	sensitive    = true{{ end }}
}

{{ end }}{{ end }}

// env variable declarations:
{{ with .Spec.Resources.Env }}
{{ range . }}variable "{{ $.Metadata.ID }}_env_{{ .Name | ToLower }}" {}

resource "tfe_variable" "{{ $.Metadata.ID }}_env_{{ .Name | ToLower }}" {
	workspace_id = tfe_workspace.{{ $.Metadata.ID }}.id
	key          = "{{ .Name }}"
	value        = var.{{ $.Metadata.ID }}_env_{{ .Name | ToLower }}
	category     = "env"{{ if .Sensitive }}
	sensitive    = true{{ end }}
}

{{ end }}{{ end }}`

	varsTemplate = `// DO NOT EDIT (this file is automatically generated)
// variable values:
{{ with .Spec.Resources.Vars }}
{{ range . }}{{ $.Metadata.ID }}_var_{{ .Name }} = {{ .Value }}
{{ end }}{{ end }}

// env variable values:
{{ with .Spec.Resources.Env }}
{{ range . }}{{ $.Metadata.ID }}_env_{{ .Name | ToLower }} = {{ .Value }}
{{ end }}{{ end }}`
)

// Workspace is a Terraform Workspace
type Workspace struct {
	Kind string `yaml:"kind"`

	Metadata struct {
		Name         string `yaml:"name"`
		ID           string `yaml:"id"`
		Shortname    string `yaml:"shortname"`
		Organization string `yaml:"organization"`
	}
	Spec WorkspaceSpec `yaml:"spec"`
}

type WorkspaceSpec struct {
	VCSRepo             VCSRepoSpec `yaml:"vcs_repo"`
	WorkingDirectory    string      `yaml:"working_directory"`
	AutoApply           bool        `yaml:"auto_apply"`
	FileTriggersEnabled bool        `yaml:"file_triggers_enabled"`
	QueueAllRuns        bool        `yaml:"queue_all_runs"`
	Resources           struct {
		Vars []Variable
		Env  []Variable
	}
}

type VCSRepoSpec struct {
	Identifier        string `yaml:"identifier"`
	Branch            string `yaml:"branch"`
	IngressSubmodules bool   `yaml:"ingress_submodules"`
	OauthTokenID      string `yaml:"oauth_token_id"`
}

type Variable struct {
	Name      string `yaml:"name"`
	Type      string `yaml:"type"`
	Value     string `yaml:"value"`
	Sensitive bool   `yaml:"sensitive"`
}

type Secrets struct {
	Kind string `yaml:"oauth_token_id"`
	Spec struct {
		Secrets []Secret `yaml:"secrets"`
	} `yaml:"spec"`
}

type Secret struct {
	Name  string `yaml:"name"`
	Value string `yaml:"value"`
}

// NewWorkspace creates a new Workspace from an input yaml file and returns a pointer to it
func NewWorkspace(file string) *Workspace {

	data, err := ioutil.ReadFile(file)
	if err != nil {
		log.Fatalf(err.Error())
	}

	w := Workspace{}

	// unmarshal our input file yaml to the struct
	err = yaml.Unmarshal([]byte(data), &w)
	if err != nil {
		log.Fatalf(err.Error())
	}

	w.Spec.Resources.Vars = initVarMap(w.Spec.Resources.Vars)
	w.Spec.Resources.Env = initVarMap(w.Spec.Resources.Env)

	return &w
}

// Output a workspace to destination files
func (w *Workspace) Output(outputDir string, outputName string, secretsFile string) {

	d := fmt.Sprintf("%s/%s.tf", outputDir, outputName)
	s := fmt.Sprintf("%s/%s.auto.tfvars", outputDir, outputName)

	// subsitute values
	w.substitute(secretsFile)

	funcMap := template.FuncMap{
		"ToLower": strings.ToLower,
	}

	// create the Terraform stanza's
	wt, err := template.New("workspace").Funcs(funcMap).Parse(workspaceTemplate)
	if err != nil {
		log.Fatalf(err.Error())
	}

	wo := bytes.Buffer{}
	err = wt.Execute(&wo, w)
	if err != nil {
		log.Fatalf(err.Error())
	}

	err = ioutil.WriteFile(d, wo.Bytes(), 0644)
	if err != nil {
		log.Fatalf(err.Error())
	}

	// create the secret values
	vt, err := template.New("vars").Funcs(funcMap).Parse(varsTemplate)
	if err != nil {
		log.Fatalf(err.Error())
	}

	so := bytes.Buffer{}
	err = vt.Execute(&so, w)
	if err != nil {
		log.Fatalf(err.Error())
	}

	err = ioutil.WriteFile(s, so.Bytes(), 0644)
	if err != nil {
		log.Fatalf(err.Error())
	}
}

// initialise variables (can be normal terraform variables of environment variables)
func initVarMap(vars []Variable) []Variable {
	for i, v := range vars {
		if v.Type == "" {
			vars[i].Type = defaultVarType
		}
	}
	return vars
}

// substitute var/env values so they're in the struct and available to the templates
func (w *Workspace) substitute(secretsFile string) {

	s := Secrets{}

	if secretsFile != "" {
		secrets, err := ioutil.ReadFile(secretsFile)
		if err != nil {
			log.Fatalf(err.Error())
		}

		// unmarshal our secret file yaml to the secrets struct
		err = yaml.Unmarshal([]byte(secrets), &s)
		if err != nil {
			log.Fatalf(err.Error())
		}
	}

	for i, t := range w.Spec.Resources.Vars {
		if t.Value == "" {
			for _, secret := range s.Spec.Secrets {
				if secret.Name == t.Name {
					t.Value = secret.Value
					break
				}
			}
		}
		if t.Type == "string" {
			w.Spec.Resources.Vars[i].Value = fmt.Sprintf("\"%s\"", t.Value)
		}
	}
	for i, t := range w.Spec.Resources.Env {
		if t.Value == "" {
			for _, secret := range s.Spec.Secrets {
				if secret.Name == t.Name {
					t.Value = secret.Value
					break
				}
			}
		}
		if t.Type == "string" {
			w.Spec.Resources.Env[i].Value = fmt.Sprintf("\"%s\"", t.Value)
		}
	}
}
